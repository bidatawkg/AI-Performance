)
SELECT
d.Market,
d.FTD_Group,
Date = d.{bucket_alias},
RMPs = COUNT(DISTINCT CASE WHEN d.RMP = 1 THEN d.PARTYID END),
FTDs = COUNT(DISTINCT CASE WHEN d.FTD = 1 THEN d.PARTYID END)
FROM Dated d
WHERE 1=1
{weekly_cut}
GROUP BY d.Market, d.FTD_Group, d.{bucket_alias}
ORDER BY d.Market, d.FTD_Group, d.{bucket_alias};
")
} else {
# MTD (use d.MonthStart fully-qualified everywhere)
body <- glue("
;WITH RU AS (
SELECT PARTYID, [Date], FTD_Since_Months
FROM bi_data.dbo.RetentionUsers
WHERE [Date] >= @CutoffDate
),
Base AS (
SELECT CAST(b.[Date] AS date) AS RawDate, b.PARTYID, b.RMP, b.FTD
FROM V_BI_MASTER_BASE_DAILY_GAME_CATEGORY b
WHERE b.[Date] >= @CutoffStart AND b.[Date] < @EndBound
),
Joined AS (
SELECT
b.RawDate, b.PARTYID, b.RMP, b.FTD,
{market_expr},
FTD_Group = {case_ftd_group}
FROM Base b
JOIN RU u ON u.PARTYID = b.PARTYID AND u.[Date] = b.RawDate
{users_join}
WHERE u.FTD_Since_Months >= 0 AND {market_where}
),
Dated AS (
SELECT
j.RawDate, j.PARTYID, j.RMP, j.FTD, j.Market, j.FTD_Group,
MonthStart = {bucket_expr}
FROM Joined j
WHERE j.FTD_Group IS NOT NULL
),
Caps AS (
SELECT
d.MonthStart,
CapDate =
CASE WHEN DATEADD(DAY, @CutoffDay - 1, d.MonthStart) > EOMONTH(d.MonthStart)
THEN EOMONTH(d.MonthStart)
ELSE DATEADD(DAY, @CutoffDay - 1, d.MonthStart) END
FROM (SELECT DISTINCT MonthStart FROM Dated) d
)
SELECT
d.Market,
d.FTD_Group,
Date = d.MonthStart,
RMPs = COUNT(DISTINCT CASE WHEN d.RMP = 1 THEN d.PARTYID END),
FTDs = COUNT(DISTINCT CASE WHEN d.FTD = 1 THEN d.PARTYID END)
FROM Dated d
JOIN Caps  c ON c.MonthStart = d.MonthStart
WHERE d.RawDate BETWEEN d.MonthStart AND c.CapDate
GROUP BY d.Market, d.FTD_Group, d.MonthStart
ORDER BY d.Market, d.FTD_Group, d.MonthStart;
")
}
sql <- paste0(header, body)
if (length(sql) != 1L || is.na(sql) || nchar(sql) == 0L) stop("build_sql() produced an empty SQL string.")
sql
}
# Runner (note: gmailr masks message(); force base::message)
run_period <- function(period) {
slices <- c("all","country","others","brand")
bind_rows(lapply(slices, function(slc) {
base::message(sprintf("Running %s - %s ...", toupper(period), toupper(slc)))
sql <- build_sql(period = period, slice = slc, cutoff = cutoff_date)
DBI::dbGetQuery(conn, sql) %>%
mutate(Slice = toupper(slc),
Date  = as.Date(Date))
})) %>%
group_by(Slice, Market, FTD_Group) %>%
arrange(Date, .by_group = TRUE) %>%
mutate(
RMPs_prev = dplyr::lag(RMPs),
Retention = ifelse(is.na(RMPs_prev) | RMPs_prev == 0,
NA_real_,
round(100 * (RMPs - FTDs) / RMPs_prev, 2))
) %>%
ungroup() %>%
select(Market, FTD_Group, Date, RMPs, FTDs,  Retention) %>%
arrange(Market, FTD_Group, Date)
}
# Build the three data frames
df_ret_weekly  <- run_period("weekly")
df_ret_monthly <- run_period("monthly")
df_ret_MTD     <- run_period("mtd")
df_ret_weekly <- df_ret_weekly %>%
group_by(Date, Market, FTD_Group) %>%
pivot_longer(
cols = c(RMPs, FTDs, Retention),
names_to = "METRIC",
values_to = "VALUE"
)
df_ret_monthly <- df_ret_monthly %>%
group_by(Date, Market, FTD_Group) %>%
pivot_longer(
cols = c(RMPs, FTDs, Retention),
names_to = "METRIC",
values_to = "VALUE"
)
df_ret_MTD <- df_ret_MTD %>%
group_by(Date, Market, FTD_Group) %>%
pivot_longer(
cols = c(RMPs, FTDs, Retention),
names_to = "METRIC",
values_to = "VALUE"
)
# Ensure Date is Date type
df$Date <- as.Date(df$Date)
# --- WEEKLY ---
df_weekly <- df %>%
mutate(Week = floor_date(Date, "week", week_start = 1)) %>%
# exclude Margin, recalc later
filter(METRIC %in% c("DEPs","FTDs","GGR","STAKE","NGR","RMPs")) %>%
group_by(Week, Market, FTD_Group, METRIC) %>%
summarise(VALUE = sum(VALUE, na.rm = TRUE), .groups = "drop") %>%
pivot_wider(names_from = METRIC, values_from = VALUE) %>%
mutate(Margin = round((GGR / STAKE) * 100, 1)) %>%
pivot_longer(-c(Week, Market, FTD_Group),
names_to = "METRIC", values_to = "VALUE") %>%
rename(Date = Week)
df_weekly <- bind_rows(df_weekly, df_ret_weekly)
# --- MONTHLY ---
df_monthly <- df %>%
mutate(Month = floor_date(Date, "month")) %>%
filter(METRIC %in% c("DEPs","FTDs","GGR","STAKE","NGR","RMPs")) %>%
group_by(Month, Market, FTD_Group, METRIC) %>%
summarise(VALUE = sum(VALUE, na.rm = TRUE), .groups = "drop") %>%
pivot_wider(names_from = METRIC, values_from = VALUE) %>%
mutate(Margin = round((GGR / STAKE) * 100, 1)) %>%
pivot_longer(-c(Month, Market, FTD_Group),
names_to = "METRIC", values_to = "VALUE") %>%
rename(Date = Month)
df_monthly <- bind_rows(df_monthly, df_ret_monthly)
# --- MTD ---
df_MTD <- df %>%
filter(METRIC %in% c("DEPs","FTDs","GGR","STAKE","NGR","RMPs"),
day(Date) <= day(yesterday)) %>%
mutate(Month = floor_date(Date, "month")) %>%
group_by(Month, Market, FTD_Group, METRIC) %>%
summarise(VALUE = sum(VALUE, na.rm = TRUE), .groups = "drop") %>%
pivot_wider(names_from = METRIC, values_from = VALUE) %>%
mutate(Margin = round(if_else(STAKE > 0, (GGR / STAKE) * 100, NA_real_), 1)) %>%
pivot_longer(-c(Month, Market, FTD_Group),
names_to = "METRIC", values_to = "VALUE") %>%
rename(Date = Month)
df_MTD <- bind_rows(df_MTD, df_ret_MTD)
# Get unique combinations of Market and METRIC
combos <- unique(df[, c("Market", "METRIC")])
# Loop through each combination
for (i in seq_len(nrow(combos))) {
mkt   <- combos$Market[i]
metr  <- combos$METRIC[i]
#Daily
df_subset <- df[df$Market == mkt & df$METRIC == metr, ]
file_name <- paste0(
"aiPerformanceFiles/", Sys.Date(),
"_ai-groups-daily_", metr, "_", mkt, ".csv"
)
write.csv(df_subset, file_name, row.names = FALSE)
#Weekly
df_subset <- df_weekly[df_weekly$Market == mkt & df_weekly$METRIC == metr, ]
file_name <- paste0(
"aiPerformanceFiles/", Sys.Date(),
"_ai-groups-weekly_", metr, "_", mkt, ".csv"
)
write.csv(df_subset, file_name, row.names = FALSE)
#Monthly
df_subset <- df_monthly[df_monthly$Market == mkt & df_monthly$METRIC == metr, ]
file_name <- paste0(
"aiPerformanceFiles/", Sys.Date(),
"_ai-groups-monthly_", metr, "_", mkt, ".csv"
)
write.csv(df_subset, file_name, row.names = FALSE)
#MTD
df_subset <- df_MTD[df_MTD $Market == mkt & df_MTD $METRIC == metr, ]
file_name <- paste0(
"aiPerformanceFiles/", Sys.Date(),
"_ai-groups-MTD_", metr, "_", mkt, ".csv"
)
write.csv(df_subset, file_name, row.names = FALSE)
}
#####################################################################
##################### Deposit group main metrics ####################
#####################################################################
# Ensure Date is a proper Date type
df$Date <- as.Date(df$Date)
# Define "yesterday" as the max date in df
yesterday <- max(df$Date, na.rm = TRUE)
# --- MTD helpers (current month through yesterday vs same days last month) ---
mtd_start <- as.Date(format(yesterday, "%Y-%m-01"))
prev_month_start <- as.Date(format(mtd_start - 1, "%Y-%m-01"))
# Number of days in the current MTD window (0-based offset from the 1st)
mtd_offset_days <- as.integer(yesterday - mtd_start)
# End of previous month
prev_eom <- seq(prev_month_start, by = "1 month", length.out = 2)[2] - 1
# Previous MTD end = same offset days in prev month, capped at prev EOM
prev_mtd_end <- min(prev_month_start + mtd_offset_days, prev_eom)
# Period windows
periods <- list(
"Yesterday" = c(start = yesterday,       end = yesterday,
prev_start = yesterday - 1, prev_end = yesterday - 1),
"7 days"    = c(start = yesterday - 6,   end = yesterday,
prev_start = yesterday - 13, prev_end = yesterday - 7),
"30 days"   = c(start = yesterday - 29,  end = yesterday,
prev_start = yesterday - 59, prev_end = yesterday - 30),
"MTD"       = c(start = mtd_start,       end = yesterday,
prev_start = prev_month_start, prev_end = prev_mtd_end)
)
# Keep only metrics of interest
df_filtered <- df %>% filter(METRIC %in% c("DEPs",  "NGR", "STAKE", "Margin"))
# Function to calculate sums and compare with previous period
calc_period <- function(name, dates) {
current <- df_filtered %>%
filter(Date >= dates["start"] & Date <= dates["end"]) %>%
group_by(Market, METRIC, FTD_Group) %>%
summarise(VALUE = sum(VALUE, na.rm = TRUE), .groups = "drop")
previous <- df_filtered %>%
filter(Date >= dates["prev_start"] & Date <= dates["prev_end"]) %>%
group_by(Market, METRIC, FTD_Group) %>%
summarise(PREVIOUS = sum(VALUE, na.rm = TRUE), .groups = "drop")
# Join and calculate diffs
full_join(current, previous, by = c("Market", "METRIC", "FTD_Group")) %>%
mutate(
Period = name,
DIFF_ABSOLUTE = VALUE - PREVIOUS,
DIFF_PERCENTAGE = ifelse(PREVIOUS == 0, NA_real_,
round((VALUE - PREVIOUS) / PREVIOUS * 100, 2))
) %>%
select(Period, Market, METRIC, FTD_Group, VALUE, PREVIOUS, DIFF_ABSOLUTE, DIFF_PERCENTAGE)
}
# Apply to all periods and bind results
df_main_final <- bind_rows(
calc_period("Yesterday", periods[["Yesterday"]]),
calc_period("7 days",    periods[["7 days"]]),
calc_period("30 days",   periods[["30 days"]]),
calc_period("MTD",       periods[["MTD"]])
)
# Get unique markets
markets <- unique(df_main_final$Market)
# Loop through each Market and save its CSV
for (mkt in markets) {
df_Market <- df_main_final[df_main_final$Market == mkt, ]
write.csv(
df_Market,
paste0("aiPerformanceFiles/", Sys.Date(), "_ai-summary-groups_", mkt, ".csv"),
row.names = FALSE
)
}
#####################################################################
########################### VVIP Analysis ###########################
#####################################################################
query <- "
SELECT
b.[Date],
b.PARTYID,
SUM(b.DEPOSIT_AMOUNT)    AS DEPs,
SUM(b.Total_STAKE)       AS STAKE,
SUM(b.Total_GGR)         AS GGR,
SUM(b.Total_NGR)         AS NGR,
COUNT(DISTINCT CASE WHEN b.RMP = 1 THEN b.PARTYID END) AS RMPs
FROM V_BI_MASTER_BASE_DAILY_GAME_CATEGORY AS b
INNER JOIN bi_data.dbo.Users AS us
ON us.GL_ACCOUNT = b.PARTYID
WHERE
b.[Date] >= '2024-11-01'
AND us.VIP_STATUS = 6
GROUP BY
b.[Date],
b.PARTYID
"
df <- dbGetQuery(conn, query)
query <- "
SELECT
u.USERID,
u.GL_ACCOUNT AS PARTYID,
CONVERT(date, u.REG_DATE) AS REG_DATE,
CONVERT(date, fd.FTD_DATE) AS FTD_DATE,
u.COUNTRY,
CASE
WHEN a.SEO_Bool = 1        THEN CONCAT('Aff SEO (', a.BTAG, ')')
WHEN a.Affiliates_Bool = 1 THEN CONCAT('Aff Social (', a.BTAG, ')')
WHEN m.Media_Bool = 1      THEN CONCAT('Media (', m.PNID, ')')
ELSE 'Organic'
END AS Source,
CASE
WHEN u.BRANDID = 1 THEN 'YYY'
WHEN u.BRANDID = 2 THEN 'YYY EN'
WHEN u.BRANDID = 3 THEN 'Y88'
WHEN u.BRANDID = 6 THEN 'BetJordan'
ELSE 'YYY GLOBAL'
END AS BRAND
FROM bi_data.dbo.USERS AS u
LEFT JOIN (
SELECT DISTINCT
PARTYID,
PNID,
1 AS Media_Bool,
Source AS SourceMedia
FROM bi_data.dbo.MediaCost_NRT ) m ON m.PARTYID = u.GL_ACCOUNT
LEFT JOIN (
SELECT DISTINCT
af.PARTYID,
af.BTAG,
1 AS Affiliates_Bool,
CASE WHEN d.Source = 'SEO' THEN 1 ELSE 0 END AS SEO_Bool
FROM bi_data.dbo.AffiliatesCost_NRT AS af
LEFT JOIN (SELECT DISTINCT BTAG, Source FROM bi_data.dbo.AffiliatesDIC_NRT) AS d
ON d.BTAG = af.BTAG
) a
ON a.PARTYID = u.GL_ACCOUNT
LEFT JOIN bi_data.dbo.V_FTD_DATE AS fd
ON fd.PARTYID = u.GL_ACCOUNT
WHERE u.VIP_STATUS = 6;
"
df_users_vvips <- dbGetQuery(conn, query)
df <- df %>% mutate(Date = as_date(Date))
# ---- Aggregation helper ----
agg_block <- function(data) {
summarise(
data,
DEPs  = sum(DEPs,  na.rm = TRUE),
STAKE = sum(STAKE, na.rm = TRUE),
GGR   = sum(GGR,   na.rm = TRUE),
NGR   = sum(NGR,   na.rm = TRUE),
RMPs  = max(RMPs,  na.rm = TRUE)
)
}
# ---- Period definitions ----
periods <- list(
YESTERDAY = expr(Date == yesterday),
PREV_DAY  = expr(Date == (yesterday - days(1))),
LAST_7D   = expr(Date >= (yesterday - days(6)) & Date <= yesterday),
PREV_7D   = expr(Date >= (yesterday - days(13)) & Date <= (yesterday - days(7))),
LAST_30D  = expr(Date >= (yesterday - days(29)) & Date <= yesterday),
PREV_30D  = expr(Date >= (yesterday - days(59)) & Date <= (yesterday - days(30))),
MTD  = expr(Date >= mtd_start & Date <= yesterday),
PMTD = expr({
prev_month_start <- mtd_start %m-% months(1)
prev_month_end   <- prev_month_start + days(day(yesterday) - 1)
Date >= prev_month_start & Date <= prev_month_end
})
)
# ---- Compute period aggregations ----
build_period <- function(name, predicate_expr) {
df %>%
filter(!!predicate_expr) %>%
group_by(PARTYID) %>%
agg_block() %>%
ungroup() %>%
mutate(Period = name)
}
# âœ… Correct order for imap_dfr: first the predicate, then the name
pieces <- imap_dfr(periods, ~ build_period(.y, .x))
# ---- Long format + differences ----
pair_map <- list(
YESTERDAY = "PREV_DAY",
LAST_7D   = "PREV_7D",
LAST_30D  = "PREV_30D",
MTD       = "PMTD"
)
long_df <- pieces %>%
pivot_longer(cols = c(DEPs, STAKE, GGR, NGR, RMPs),
names_to = "METRIC", values_to = "VALUE")
df_final <- imap_dfr(pair_map, function(prev, curr) {
current_df  <- filter(long_df, Period == curr) %>%
mutate(VALUE = coalesce(as.numeric(VALUE), 0))
previous_df <- filter(long_df, Period == prev) %>%
rename(PREVIOUS = VALUE) %>%
mutate(PREVIOUS = as.numeric(PREVIOUS)) %>%
select(PARTYID, METRIC, PREVIOUS)
full_join(current_df, previous_df, by = c("PARTYID", "METRIC")) %>%
# fill missing after the join
mutate(
VALUE    = coalesce(VALUE, 0),
PREVIOUS = coalesce(PREVIOUS, 0)
) %>%
mutate(
Period = curr,
DIFF_ABSOLUTE  = VALUE - PREVIOUS,
DIFF_PERCENTAGE = ifelse(PREVIOUS == 0, NA_real_,
(VALUE - PREVIOUS) / PREVIOUS * 100)
) %>%
mutate(across(c(VALUE, PREVIOUS, DIFF_ABSOLUTE, DIFF_PERCENTAGE), ~ round(.x, 0))) %>%
# drop rows where both VALUE and PREVIOUS are 0
filter(!(VALUE == 0 & PREVIOUS == 0))
})
df_final <- df_final %>%
select(Period, PARTYID, METRIC, VALUE, PREVIOUS, DIFF_ABSOLUTE, DIFF_PERCENTAGE) %>%
arrange(PARTYID, Period, METRIC)
# Add player attributes
df_final <- merge(df_final, df_users_vvips, by = "PARTYID")
df_final_markets <- df_final %>%
mutate(
MarketList = pmap(
list(COUNTRY, BRAND),
function(country, brand) {
markets <- c("ALL", country)  # always ALL + the country itself
# Special cases
if (!is.na(country) && !is.na(brand)) {
if (country != "EG" && brand == "YYY") markets <- c(markets, "GCC")
if (brand == "BetJordan") markets <- c(markets, "BET")
if (!(country %in% c("AE","BH","EG","JO","KW","QA","SA","NZ"))) markets <- c(markets, "Others")
}
unique(markets)
}
)
) %>%
unnest_longer(MarketList, values_to = "Market") %>%
select(Period, PARTYID, METRIC, VALUE, PREVIOUS, DIFF_ABSOLUTE, DIFF_PERCENTAGE,
USERID, REG_DATE, FTD_DATE, COUNTRY, Source, BRAND, Market) %>%
arrange(PARTYID, Period, METRIC, Market)
df_final_markets <- df_final_markets %>%
# keep only the four target periods in case others slipped in
filter(Period %in% c("YESTERDAY", "LAST_7D", "LAST_30D", "MTD")) %>%
mutate(
Period = dplyr::recode(
Period,
YESTERDAY = "Yesterday",
LAST_7D   = "7 days",
LAST_30D  = "30 days",
MTD       = "MTD",
.default  = Period
)
) %>%
select(
Period, Market, PARTYID, USERID, Source,
REG_DATE, FTD_DATE, METRIC, VALUE, PREVIOUS,
DIFF_ABSOLUTE, DIFF_PERCENTAGE
)
# Get unique markets
markets <- unique(df_final_markets$Market)
# Loop through each Market and save its CSV
for (mkt in markets) {
df_Market <- df_final_markets[df_final_markets$Market == mkt, ]
write.csv(
df_Market,
paste0("aiPerformanceFiles/", Sys.Date(), "_ai-VVIPs-table_", mkt, ".csv"),
row.names = FALSE
)
}
#####################################################################
############################# VVIP Churn ############################
#####################################################################
query <- "
-- VVIPs with NO RMP=1 and NO deposits > 0 in the last 14 days (excluding today)
SELECT
us.GL_ACCOUNT AS PARTYID,
CONVERT(date, us.LAST_DEPOSIT_DATE) AS Last_DEP,
us.LAST_DEPOSIT_AMOUNT AS Last_DEP_VALUE,
CONVERT(date, us.LAST_WITHDRAW_DATE) AS Last_WD,
us.LAST_WITHDRAW_AMOUNT AS Last_WD_VALUE
FROM bi_data.dbo.Users AS us
WHERE
us.VIP_STATUS = 6
AND NOT EXISTS (
SELECT 1
FROM V_BI_MASTER_BASE_DAILY_GAME_CATEGORY AS b
WHERE
b.PARTYID = us.GL_ACCOUNT
AND b.[Date] >= DATEADD(day, -14, CAST(GETDATE() AS date))  -- 14 days ago
AND b.[Date]  < CAST(GETDATE() AS date)                      -- up to yesterday
AND (b.RMP = 1 OR b.DEPOSIT_AMOUNT > 0)
);
"
df <- dbGetQuery(conn, query)
df_lastbet <- dbGetQuery(conn, "SELECT
v.PARTYID,
CONVERT(date, v.[DATETIME]) AS Last_BET
FROM bi_data.dbo.V_PARTYID_MAX_DATE_BET AS v
INNER JOIN bi_data.dbo.Users AS us
ON us.GL_ACCOUNT = v.PARTYID
WHERE
us.VIP_STATUS = 6"
)
# Add player attributes
df <- merge(df_lastbet, df, by = "PARTYID")
df <- merge(df_users_vvips, df, by = "PARTYID")
df <- subset(df, !is.na(FTD_DATE))
df <- df %>%
mutate(
MarketList = pmap(
list(COUNTRY, BRAND),
function(country, brand) {
markets <- c("ALL", country)  # always ALL + the country itself
# Special cases
if (!is.na(country) && !is.na(brand)) {
if (country != "EG" && brand == "YYY") markets <- c(markets, "GCC")
if (brand == "BetJordan") markets <- c(markets, "BET")
if (!(country %in% c("AE","BH","EG","JO","KW","QA","SA","NZ"))) markets <- c(markets, "Others")
}
unique(markets)
}
)
) %>%
unnest_longer(MarketList, values_to = "Market")
df$COUNTRY = NULL
df$BRAND = NULL
write.csv(
df,
paste0("aiPerformanceFiles/", Sys.Date(), "_ai-VVIPs-Churn", ".csv"),
row.names = FALSE
)
